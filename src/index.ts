import { Arbitrary, asyncProperty, check, Parameters, RunDetails } from 'fast-check';

export type CheckStatus = boolean | void;
export type Check<T> = (this: Mocha.Context, val: T) => never | CheckStatus | Promise<CheckStatus>;
export type WrappedIt<T> = (name: string, check: Check<T>) => void;
export type Suite<T> = (it: WrappedIt<T>) => void;

export type ErrorReporter<T> = (details: RunDetails<T>) => string | undefined;
export interface ErrorParameters<T> extends Parameters<T> {
  errorReporter?: ErrorReporter<T>;
}

/**
 * Run a suite of test scenarios with the same arbitrary `strategy`. Each test in the `suite` will be run separately
 * with its own set of values, generated by the fast-check runner.
 *
 * This is a wrapper for Mocha's `describe`, and the `it` function passed to `suite` is a wrapper for Mocha's `it`.
 * Most Mocha features, like `beforeEach` hooks, should work normally and will operate at the `over` level.
 *
 * @param name the suite name, as you would pass to `describe(name, suite)`
 * @param strategy a fast-check `Arbitrary` used to produce semi-random values
 * @param suite the test suite, as you would pass to `describe(name, suite)`
 * @param parameters additional parameters to the fast-check `Runner`
 * @throws Error when the property check fails
 * @public
 */
export function over<T>(name: string, strategy: Arbitrary<T>, suite: Suite<T>, parameters: ErrorParameters<T> = {}): void {
  describe(name, () => {
    suite((name, test) => {
      it(name, function (this: Mocha.Context): Promise<void> {
        const ctx = this;
        // something about check's type signature requires examples to be tuples,
        // which leads to triple-wrapping examples for tuple properties. help remove one layer
        const examples: Array<[T]> = parameters.examples?.map((it) => [it]) || [];
        const checkParameters: Parameters<[T]> = {
          ...parameters,
          // clear these in favor of the errorReporter
          asyncReporter: undefined,
          reporter: undefined,
          examples,
        };
        const reporter = (parameters.errorReporter || briefReporter) as ErrorReporter<[T]>;

        // wrap the strategy arbitrary in a property checking the test fn
        // TODO: switch between property and asyncProperty as needed
        const property = asyncProperty(strategy, (val) => Promise.resolve(test.call(ctx, val)));
        return Promise.resolve(check(property, checkParameters)).then((result) => {
          if (result.failed) {
            throw new Error(reporter(result));
          } else {
            return undefined;
          }
        });
      });
    });
  });
}

/**
 * Format the details of a fast-check run. This always returns a string and will not throw or print to the console,
 * whether the run was successful or failed. This is compatible with fast-check's `defaultReportMessage` function,
 * but produces a shorter message.
 *
 * @public
 */
export function briefReporter<T>(details: RunDetails<[T]>): string {
  const prefix = formatPrefix(details);
  const counts = `${prefix} after ${details.numRuns} runs and ${details.numShrinks} shrinks`;
  const examples = formatExamples(details);

  if (isErrorRun(details)) {
    return `${counts}, ${examples}\n${details.error}`;
  } else {
    return `${counts}, ${examples}`;
  }
}

/**
 * Format the counterexamples in a run's details.
 *
 * @private
 */
export function formatExamples<T>(details: RunDetails<[T]>): string {
  if (details.counterexample !== null) {
    const examples = details.counterexample.map((val) => JSON.stringify(val)).join(',');
    return `failing on: ${examples} (seed: ${details.seed}, path: '${details.counterexamplePath}')`;
  } else {
    return `without counterexamples (seed: ${details.seed})`;
  }
}

/**
 * Format the friendly prefix for the run details, indicating whether it returned false or threw an error.
 *
 * @private
 */
export function formatPrefix<T>(details: RunDetails<[T]>): string {
  if (isErrorRun(details)) {
    return 'Property failed by throwing an error';
  }

  if (isString(details.error)) {
    return details.error;
  }

  return 'Property failed without a reason';
}

/**
 * Guess whether the run threw an error. Looks for strings starting with `Error` or a typed error
 * like `AssertionError`.
 *
 * @private
 */
export function isErrorRun<T>(details: RunDetails<T>): boolean {
  if (isString(details.error)) {
    return /^([A-Z][a-z]*)*Error:/.test(details.error);
  }

  return false;
}

/**
 * Typeguard for string primitives.
 *
 * @private
 */
export function isString(val: unknown): val is string {
  return typeof val === 'string';
}
